/*
 * From https://docs.rs/libtool/0.1.1/libtool/
 * Upstream doesn't handle some of the directory structure we use in Petitboot,
 * use a few extra environment variables to properly determine the target paths.
 */

use std::env;
use std::fs::File;
use std::fs;
use std::io::prelude::*;
use std::os::unix::fs::symlink;
use std::path::PathBuf;

/// Generate libtool archive file ${lib}.la
pub fn generate_convenience_lib(lib: &str) -> std::io::Result<()> {
    let self_version = env!("CARGO_PKG_VERSION");
    let profile = env::var("PROFILE").unwrap();
    let target_arch = env::var("TARGET").unwrap();
    let target_dir_env = env::var("CARGO_TARGET_DIR").unwrap();

    /* Check if the output directory will include the arch */
    let target_dir = if PathBuf::from(format!("{}/{}",
                                target_dir_env, target_arch)).exists() {
        format!("{}/{}/{}", target_dir_env, target_arch, profile)
    } else {
        format!("{}/{}", target_dir_env, profile)
    };

    /* Location of original static library */
    let old_lib_path = PathBuf::from(format!("{}/{}.a",
                                            target_dir, lib));
    /* Paths for new .la file and symlinks */
    let libs_dir = format!("{}/.libs", target_dir);
    let libs_path = PathBuf::from(&libs_dir);
    let la_path = PathBuf::from(format!("{}/{}.la",
                                        target_dir, lib));
    let new_lib_path = PathBuf::from(format!("{}/{}.a", libs_dir, lib));

    match fs::create_dir_all(&libs_path) {
        Ok(()) => println!("libs_path created"),
        _ => panic!("Failed to create libs_path"),
    }

    if la_path.exists() {
        fs::remove_file(&la_path)?;
    }

    /* PathBuf.exists() traverses symlinks so just try and remove it */
    match fs::remove_file(&new_lib_path) {
        Ok(_v) => {},
        Err(e) => println!("Error removing symlink: {:?}", e),
    }

    let mut file = File::create(&la_path)?;
    writeln!(file, "# {}.la - a libtool library file", lib)?;
    writeln!(file, "# Generated by libtool-rust {}", self_version)?;
    writeln!(file, "dlname=''")?;
    writeln!(file, "library_names=''")?;
    writeln!(file, "old_library='{}.a'", lib)?;
    writeln!(file, "inherited_linker_flags=' -pthread -lm -ldl'")?;
    writeln!(file, "installed=no")?;
    writeln!(file, "shouldnotlink=no")?;

    symlink(&old_lib_path, &new_lib_path)?;
    Ok(())
}

fn main() {
    generate_convenience_lib("librustlibs").unwrap();
}
